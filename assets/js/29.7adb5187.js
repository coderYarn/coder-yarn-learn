(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{630:function(t,a,v){"use strict";v.r(a);var _=v(15),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),v("p",[t._v("https 是一个位于应用层 和 传输层之间的一个加密协议，采用了对称加密和非对称加密的结合的方式来加密数据")]),t._v(" "),v("h2",{attrs:{id:"什么是对称加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是对称加密"}},[t._v("#")]),t._v(" 什么是对称加密?")]),t._v(" "),v("p",[t._v("对称加密，就是客户端/服务端，使用同一套密钥，该密钥可以用来加密一段数据，也可以用来解密一段数据。")]),t._v(" "),v("ul",[v("li",[t._v("优点:加密效率高")]),t._v(" "),v("li",[t._v("缺点:密钥容易被窃取，存在一定的安全问题")])]),t._v(" "),v("h2",{attrs:{id:"什么是非对称加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是非对称加密"}},[t._v("#")]),t._v(" 什么是非对称加密?")]),t._v(" "),v("p",[t._v("非对称加密:即密钥分为"),v("em",[t._v("公钥")]),t._v("和"),v("em",[t._v("私钥")]),t._v(",公钥通常存放再客户端，"),v("em",[t._v("私钥")]),t._v("通常存放在服务端，用"),v("em",[t._v("公钥")]),t._v("加密的数据，只能用"),v("em",[t._v("私钥")]),t._v("来解密，用"),v("em",[t._v("私钥")]),t._v("加密的数据，只能用"),v("em",[t._v("公钥")]),t._v("来解密")]),t._v(" "),v("ul",[v("li",[t._v("优点:安全性高")]),t._v(" "),v("li",[t._v("缺点:加密效率低")])]),t._v(" "),v("h2",{attrs:{id:"hash算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash算法"}},[t._v("#")]),t._v(" hash算法")]),t._v(" "),v("p",[t._v("hash算法又称（散列算法），把任意长度的输入通过散列函数变化为固有长度的输出，该输出就是散列值，可以用一种较短的信息来表示输入信息的的唯一性。")]),t._v(" "),v("ul",[v("li",[t._v("正向快速:给定指定的明文和Hash算法，能在有限的资源和时间内计算出散列值")]),t._v(" "),v("li",[t._v("逆向困难:在有限的时间内，无法推断出明文")]),t._v(" "),v("li",[t._v("输入敏感:铭文的微小变动，产生的散列值的差异是巨大的")])]),t._v(" "),v("h2",{attrs:{id:"https的加密机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https的加密机制"}},[t._v("#")]),t._v(" https的加密机制")])])}),[],!1,null,null,null);a.default=s.exports}}]);